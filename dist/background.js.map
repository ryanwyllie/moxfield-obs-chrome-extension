{"version":3,"file":"background.js","mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://moxfield-obs-chrome-extension/./src/background.ts"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nlet battlefieldWindowId;\nchrome.runtime.onInstalled.addListener(() => {\n    chrome.action.disable();\n    chrome.declarativeContent.onPageChanged.removeRules(undefined, () => {\n        chrome.declarativeContent.onPageChanged.addRules([\n            {\n                conditions: [\n                    new chrome.declarativeContent.PageStateMatcher({\n                        pageUrl: {\n                            hostSuffix: 'moxfield.com',\n                            pathPrefix: '/decks/',\n                            pathSuffix: '/goldfish'\n                        },\n                    }),\n                ],\n                actions: [new chrome.declarativeContent.ShowAction()],\n            },\n        ]);\n    });\n});\n// For message listeners that need to use sendResponse, we need to handle them differently\n// We'll use a new pattern that returns true to indicate we'll send a response asynchronously\nchrome.runtime.onMessage.addListener(async (message, sender, sendResponse) => {\n    if (message.type !== 'LAUNCH') {\n        return;\n    }\n    ;\n    const { width, height, tabId } = message;\n    const newWindow = await getOrCreateWindow(battlefieldWindowId, tabId);\n    battlefieldWindowId = newWindow.id;\n    if (!battlefieldWindowId) {\n        return;\n    }\n    chrome.windows.update(battlefieldWindowId, {\n        focused: true,\n        width,\n        height,\n    });\n});\nasync function getOrCreateWindow(windowId, tabId) {\n    return windowId == null\n        ? chrome.windows.create({\n            url: chrome.runtime.getURL(`battlefield.html?tabId=${tabId}`),\n            type: 'popup',\n        })\n        : chrome.windows.get(windowId);\n}\nasync function cleanupBattlefieldWindow() {\n    try {\n        if (battlefieldWindowId && await chrome.windows.get(battlefieldWindowId)) {\n            await chrome.windows.remove(battlefieldWindowId);\n        }\n    }\n    catch {\n    }\n    battlefieldWindowId = undefined;\n}\nchrome.windows.onRemoved.addListener((windowId) => {\n    if (windowId === battlefieldWindowId) {\n        cleanupBattlefieldWindow();\n    }\n});\n"],"names":[],"sourceRoot":""}